declare module "odin" {
    /**
     * 输出Log
     * @param content 内容
     */
    export function oTrace(...content: any[]): void;
    /**
     * 输出Warning
     * @param content 内容
     */
    export function oTraceWarning(...content: any[]): void;
    /**
     * 输出Error
     * @param content 内容
     */
    export function oTraceError(...content: any[]): void;
    export class LogManager {
        static instance: LogManager;
        constructor();
        destroy(): void;
        private logLevel;
        private _firstWithEnable;
        /**
         * 设置所有的打印是否带______[OdinLog]前缀
         */
        set firstWithEnable(value: boolean);
        /**
         * 设置输出的等级
         * @param value 等级值(0-全部 1-Error&Warning 2-Error)
         */
        setLogLevel(value: number): void;
        /**
         * 输出Log
         * @param content 内容
         */
        log(...content: any[]): void;
        /**
         * 输出带tag的Log，便于搜索
         * @param tag tag
         * @param content 内容
         */
        logWithTag(tag: string, ...content: any[]): void;
        /**
         * 输出Warning
         * @param content 内容
         */
        logWarning(...content: any[]): void;
        /**
         * 输出带tag的Warning，便于搜索
         * @param tag tag
         * @param content 内容
         */
        logWarningWithTag(tag: string, ...content: any[]): void;
        /**
         * 输出Error
         * @param content 内容
         */
        logError(...content: any[]): void;
        /**
         * 输出带tag的Error，便于搜索
         * @param tag tag
         * @param content 内容
         */
        logErrorWithTag(tag: string, ...content: any[]): void;
        private getFirstWith;
    }
}

declare module "odin" {
    /**
    * 类定义，使用这个可以省去类参数繁琐的类型声明    如:fun<T>(c:{new():T}) 可以写成 fun<T>(c:Class<T>)
    */
    export interface Class<T> extends Function {
        new (...args: any[]): T;
    }
    /**
     * 可以被序列化的Map
     */
    export type ObjMap<T> = {
        [key: string]: T;
    };
    /**回调体，用于Action和Event系统的辅助功能*/
    export class CallBack {
        private fun;
        private thisArg;
        dirty: boolean;
        constructor(fun: Function, thisArg: any);
        call(...prames: any[]): any;
        isOriginFrom(fun: Function, thisArg: any): boolean;
        get originFun(): Function;
        get originThisArg(): any;
    }
    /**任意参数的代理*/
    export class Action {
        protected funArgList: Array<CallBack>;
        private callingRemNum;
        private countChangeCallback;
        /**
         * 添加一个监听方法(不会重复添加)
         * @param fn 方法
         * @param thisArg 域
         */
        add(fn: Function, thisArg?: any): void;
        /**
         * 移除一个监听方法
         * @param fn 方法
         * @param thisArg 域
         */
        remove(fn: Function, thisArg: any): void;
        /**
         * 执行
         * @param prams 参数序列
         */
        call(...prams: any): void;
        /**
         * 判断是否包含某个监听方法
         * @param fn 方法
         * @param thisArg 域
         * @returns 结果
         */
        includes(fn: Function, thisArg: any): boolean;
        /**
         * 清除所有监听
         */
        clear(): void;
        /**
         * 监听方法的数量
         */
        get count(): number;
        /**
         * 设置长度变化的回调方法
         * @param callback 方法
         */
        setCountChangeCallback(callback: Function): void;
        private getFunIndex;
        private getCallBack;
    }
    /**一个参数的代理*/
    export class Action1<T> extends Action {
        add(fn: (a: T) => void, thisArg?: any): void;
        remove(fn: (a: T) => void, thisArg: any): void;
        call(arg: T): void;
    }
    /**二个参数的代理*/
    export class Action2<T, S> extends Action {
        add(fn: (a: T, b: S) => void, thisArg?: any): void;
        remove(fn: (a: T, b: S) => void, thisArg: any): void;
        call(a: T, b: S): void;
    }
    export function Singleton(): (type: {
        new ();
        instance: any;
    }) => {
        new (): any;
        instance: any;
    };
}

declare module "odin" {
    export class DataInfo {
        version: number;
    }
}

declare module "odin" {
    export class PlayerData {
        private playerId;
        private dataMap;
        private moduleDataMap;
        constructor(playerId: number, dataMap: any);
        getModuleData<T extends ModuleData<any>>(ModuleDataClass: Class<T>): T;
        get dataInfoMap(): any;
        destroy(): void;
    }
}

declare module "odin" {
    export class DataCenterS {
        private static _instance;
        private constructor();
        static get instance(): DataCenterS;
        destroy(): void;
        private readonly INIT_PLAYER_DATA_ASK;
        private readonly INIT_PLAYER_DATA_REPLY;
        private readonly PLAYER_DATA_CHANGE_NOTIFY;
        private readonly SAVE_DELAY_SECOND;
        readonly onPlayerJoined: Action1<GamePlay.Player>;
        readonly onPlayerLeft: Action1<GamePlay.Player>;
        private playerDataMap;
        private toBeSavedMap;
        private onlinePlayerIds;
        /**初始化 */
        init(): void;
        private loadPlayerData;
        private unloadPlayerData;
        private savePlayerData;
        getPlayerData(player: GamePlay.Player | number): PlayerData;
        /**
         * 获取一个玩家的一个模块数据
         * @param player 玩家
         * @param ModuleDataClass 模块数据类
         * @returns 模块数据对象
         */
        getModuleData<T extends ModuleData<DataInfo>>(player: GamePlay.Player | number, ModuleDataClass: Class<T>): T;
        /**
         * 存储模块数据
         * @param moduleData 模块数据
         * @returns 是否成功
         */
        saveModuleData<T extends ModuleData<DataInfo>>(moduleData: T, syncToClient: boolean): boolean;
        /**
         * 获取在线的所有玩家的ID数组
         * @returns 在线玩家id数组
         */
        getPlayerIDs(): Array<number>;
    }
}

declare module "odin" {
    export class ModuleData<T extends DataInfo> {
        /** 服务器同步数据的事件(Client Only)*/
        readonly onDataChange: Action;
        private syncActionNetMsg;
        private _playerId;
        private DataInfoClass;
        private dataInfoMap;
        private syncToClient;
        protected constructor(DataInfoClass: Class<T>);
        private init;
        private destroy;
        /**数据体*/
        get dataInfo(): T;
        /**数据名称*/
        get dataName(): string;
        /**所属玩家id*/
        get playerId(): number;
        /**
         * 初始化默认数据，需要请复写
         */
        protected initDefaultData(): void;
        /**
         * 保存模块数据(Server Only)
         * @param syncToClient 是否同步给客户端
         * @returns 模块数据自身
         */
        saveData(syncToClient: boolean): this;
    }
}

declare module "odin" {
    export class DataCenterC {
        private static _instance;
        private constructor();
        static get instance(): DataCenterC;
        destroy(): void;
        private readonly INIT_PLAYER_DATA_ASK;
        private readonly INIT_PLAYER_DATA_REPLY;
        private readonly PLAYER_DATA_CHANGE_NOTIFY;
        private playerData;
        /**
         * 初始化，获取当前玩家的所有模块数据
         */
        init(): Promise<void>;
        /**
         * 获取自己的一个模块数据
         * @param ModuleDataClass 模块数据类
         * @returns 模块数据对象
         */
        getModuleData<T extends ModuleData<DataInfo>>(ModuleDataClass: Class<T>): T;
    }
}

declare module "odin" {
    export class TimeUtil {
        /**进入帧事件(参数dt)*/
        static onEnterFrame: Action1<number>;
        private static delayExecuteFun;
        private static delayExecuteId;
        private static _delayTime;
        /**每一帧经过的时间 (单位：秒) */
        static get delayTime(): number;
        /** 游戏运行后所经过的总时长 (单位：秒)*/
        static get time(): number;
        /**
         * 延迟一定帧数执行方法
         * @param fun 执行的方法
         * @param frameNum 要延迟的帧数
         * @returns 用于停止的id
         */
        static delayExecute(fun: Function, frameNum?: number): number;
        /**
         * 清除delayExecute
         * @param id delayExecute方法返回的id
         */
        static clearDelayExecute(id: number): void;
        /**
         * 延迟一定秒数,用于异步方法中间的等待
         * @param second 时间(单位：秒)
         * @returns Promise
         */
        static delaySecond(second: number): Promise<void>;
        /**
         * 给主循环留的接口，不要调用
         * @param dt 两帧直接的时间差
         */
        static update(dt: number): void;
        private static delayExecuteUpdate;
    }
}

declare module "odin" {
    export class NetManager {
        static instance: NetManager;
        constructor();
        destroy(): void;
        private readonly ASK;
        private readonly REPLY;
        private readonly NOTIFY;
        private _logVisible;
        private funMap;
        private objFunMap;
        private objMap;
        private waitServerResolveMap;
        private _currentPlayer;
        init(): void;
        /**
         * 注册网络方法(网络方法是可以被远端调用的， 注意：注册的方法名不能重复)
         * @param fun 方法
         * @param thisArg 方法的域
         * @param callName 调用别名(默认为方法名)
         */
        registerFun(fun: Function, thisArg: any, callName?: string): void;
        /**
         * 移除注册的网络方法
         * @param fun 方法
         */
        unRegisterFun(fun: Function): void;
        /**
         * 注册网络对象(网络对象里的方法都是可以被远端调用的)
         * @param netObj 网络对象
         * @param netGuid 通信id
         */
        registerObj(netObj: any, netGuid: string): void;
        /**
         * 移除注册的网络对象
         * @param netObj 对象
         */
        unRegisterObj(netObj: any): void;
        /**
         * 调用服务端方法
         * @param fun 方法路径|方法
         * @param params 参数
         * @returns 方法的返回值
         */
        callServerFun(fun: string | Function, ...params: any[]): Promise<any>;
        /**
         * 调用目标客户端的方法
         * @param player 目标玩家
         * @param fun 方法路径|方法
         * @param params 参数
         */
        callClientFun(player: GamePlay.Player, fun: string | Function, ...params: any[]): any;
        /**
         * 调用目标玩家周围客户端的方法
         * @param player 目标玩家
         * @param fun 方法路径|方法
         * @param params 参数
         */
        callAroundClientFun(player: GamePlay.Player, fun: string | Function, ...params: any[]): any;
        /**
         * 调用所有客户端的方法
         * @param fun 方法路径|方法
         * @param params 参数
         */
        callWorldClientFun(fun: string | Function, ...params: any[]): any;
        /**是否显示通信log */
        set logVisible(value: boolean);
        /**
         * 当前调用服务器方法的玩家
         */
        get currentPlayer(): GamePlay.Player;
        private getFunction;
        private showLog;
    }
}

declare module "odin" {
    export enum EffectPlayerType {
        Pos = 1,
        Player = 2,
        GameObject = 3
    }
    export class EffectData {
        private static currentPlayId;
        playId: number;
        resId: string;
        playType: EffectPlayerType;
        loopNum: number;
        targetGoGuid: string;
        targetPlayerId: number;
        socketType: GamePlay.CharacterSocketType;
        position: Type.Vector;
        angles: Type.Vector;
        scale: Type.Vector;
        private constructor();
        /**
         * 获取在一个坐标播放特效的数据
         * @param resGuid 特效资源guid
         * @param position 坐标
         * @param loopNum 循环次数(0无限)
         * @param angles 角度
         * @returns 特效播放数据
         */
        static getPlayInPos(resGuid: string, position: Type.Vector, loopNum: number, angles: Type.Vector, scale: Type.Vector): EffectData;
        static getPlayInPlayer(resGuid: string, player: GamePlay.Player, socketType: GamePlay.CharacterSocketType, loopNum: number, offset: Type.Vector, angles: Type.Vector, scale: Type.Vector): EffectData;
        static getPlayInGameObject(resGuid: string, target: MWCore.GameObject, loopNum: number, offset: Type.Vector, angles: Type.Vector, scale: Type.Vector): EffectData;
        static isReady(data: EffectData): boolean;
        static EffIsDepend(effData: EffectData, targetId: string | number): boolean;
        private static getNewPlayId;
    }
}

declare module "odin" {
    export class Effect {
        private _resId;
        private go;
        private playTime;
        private totalPlayerTime;
        private startPlayTime;
        private effectData;
        private isWaitParent;
        private delayPlayFrame;
        private delayPlayId;
        /**
         * 构造
         * @param resId 资源id
         * @param playTime 播放的总时长(单位:秒)
         */
        constructor(resId: string, playTime: number);
        private static isAssetId;
        private init;
        play(data: EffectData): number;
        private playHandle;
        /**编辑器特效对象 */
        get mwEffect(): GamePlay.EffectSystem;
        /**
         * 是否依赖一个对象
         * @param targetId gameObejct的guid|player的playerId
         * @returns 结果
         */
        isDepend(targetId: string | number): boolean;
        stop(): void;
        get playId(): number;
        get resId(): string;
        get isDone(): boolean;
        update(): boolean;
        clone(): Effect;
    }
}

declare module "odin" {
    export class EffectManager {
        static instance: EffectManager;
        constructor();
        destroy(): void;
        private effDataMap;
        private effectMap;
        private pool;
        private playingEffectArr;
        private playingEffectMap;
        private loopEffectDataOnServer;
        init(): void;
        /**
         * 注册预加载特效(框架方法，请勿调用)
         * @param name 调用名称
         * @param guid 资源id
         * @param time 播放时长(单位：秒)
         */
        registerPreload(name: string, guid: string, time: number): void;
        /**
         * 预加载特效资源(框架方法，请勿调用)
         * @returns 是否全部成功
         */
        preloadEffect(): Promise<boolean>;
        private playEffect;
        /**
         * 在一个角色的挂点上播放特效（可双端调用)
         * @param resId 特效资源id
         * @param player 玩家
         * @param socketType 挂点类型
         * @param loopNum 循环次数(0为无限)
         * @param offset 坐标偏移
         * @param angles 角度
         * @param scale 缩放
         * @returns playId，本次播放的唯一标识，可用于停止
         */
        playEffectInPlayer(resId: string, player: GamePlay.Player, socketType: GamePlay.CharacterSocketType, loopNum?: number, offset?: Type.Vector, angles?: Type.Vector, scale?: Type.Vector): number;
        /**
         * 在一个GameObject上播放特效（可双端调用)
         * @param resId 特效资源id
         * @param target 目标GameObject | 目标GameObject的guid
         * @param loopNum 循环次数(0为无限)
         * @param offset 坐标偏移
         * @param angles 角度
         * @param scale 缩放
         * @returns playId，本次播放的唯一标识，可用于停止
         */
        playEffectInGameObject(resId: string, target: MWCore.GameObject, loopNum?: number, offset?: Type.Vector, angles?: Type.Vector, scale?: Type.Vector): number;
        /**
         * 在一个坐标上播放特效（可双端调用)
         * @param resId 特效资源id
         * @param pos 世界坐标
         * @param loopNum 循环次数(0为无限)
         * @param angles 角度
         * @param scale 缩放
         * @returns playId，本次播放的唯一标识，可用于停止
         */
        playEffectInPos(resId: string, pos: Type.Vector, loopNum?: number, angles?: Type.Vector, scale?: Type.Vector): number;
        /**
         * 停止目标对象上所有资源id的特效（可双端调用)
         * @param resId 特效资源id
         * @param target 目标对象(Player或者GameObject)
         */
        stopEffectFromHost(resId: string, target?: GamePlay.Player | MWCore.GameObject): void;
        private stopEffectFromHost_Executor;
        /**
         * 停止一个特效的播放（可双端调用)
         * @param playId 播放id
         */
        stopEffect(playId: number): void;
        /**
         * 根据播放id获取特效
         * @param playId 播放id
         * @returns 特效
         */
        getEffect(playId: number): Effect;
        private update;
        private spawnEffect;
        private returnEffect;
    }
}

declare module "odin" {
    export interface IModule {
        /**创建调用*/
        onAwake(): void;
        /**开始调用*/
        onStart(): void;
        /**刷新调用*/
        onUpdate(dt: number): void;
        /**销毁调用*/
        onDestroy(): void;
        /**
         * 外部调用本模块的操作
         * @type type 操作类型
         * @param param 参数
         */
        execute(type?: number, param?: any): void;
    }
}

declare module "odin" {
    export class StringUtil {
        /**
         * 获取一个Vector的字符串表达
         * @param v 向量
         * @returns 字符串
         */
        static getVectorString(v: Type.Vector): string;
        /**
         * 判断字符串是否为空(null或"")
         * @param str 要判断的字符串
         * @returns 结果
         */
        static isEmpty(str: string): boolean;
        /**
         * 将{i}中的内容依次替换为后续参数,i从0开始
         * @param str 要处理的字符串
         * @param param 替换序列
         * @returns 新的字符串
         */
        static format(str: string, ...param: any[]): string;
    }
}

declare module "odin" {
    export class NetObject {
        private _netGuid;
        constructor(netGuid: string);
        get netGuid(): string;
        /**
         * 将自己注册到Net上，可供远端调用
         */
        registerToNet(): void;
    }
}

declare module "odin" {
    export class NetObjectC<T> extends NetObject {
        private _server;
        private netFunNameMap;
        /**
         * 构造
         * @param netGuid 通信id
         * @param ServerClass 服务端类
         * @param autoRegister 是否自动注册
         */
        constructor(netGuid: string, ServerClass: Class<T>, autoRegister?: boolean);
        private serverClassToCallHander;
        private replaceNetFun;
        private getCallServerFun;
        /**
         * 调用服务端方法
         * @param fun 服务端方法名|服务端方法对象
         * @param prames 参数
         * @returns 方法返回值
         */
        protected callServerFun(fun: string | Function, ...prames: any[]): Promise<any>;
        /**
         * 和自己绑定的服务端对象，可通过此对象直接调用net_开头的服务端方法
         */
        protected get server(): T;
    }
}

declare module "odin" {
    export abstract class ModuleC<T, S extends ModuleData<any>> extends NetObjectC<T> implements IModule {
        private ModuleDataClass;
        /**
         * 构造(不要手动构造模块，请在GameStart中注册)
         * @param ServerModuleClass 模块服务端类
         * @param ModuleDataClass 模块数据类
         * @param netGuid 通信id
         */
        constructor(ServerModuleClass: Class<T>, ModuleDataClass: Class<S>, netGuid: string);
        /**获取当前玩家*/
        protected get currentPlayer(): GamePlay.Player;
        /**获取模块数据*/
        protected get data(): S;
        /**创建调用*/
        onAwake(): void;
        /**开始调用*/
        onStart(): void;
        /**进入场景调用*/
        onEnterScene(sceneType: number): void;
        /**刷新调用*/
        onUpdate(dt: number): void;
        /**销毁调用*/
        onDestroy(): void;
        /**
         * 外部调用本模块的某个操作
         * @type type 操作类型
         * @param param 参数
         */
        execute(type?: number, param?: any): void;
        /**等待资源 */
        onWaitAsset(sceneType: number): Promise<void>;
    }
}

declare module "odin" {
    export class ModuleManager {
        static instance: ModuleManager;
        destroy(): void;
        private moduleMapType;
        private moduleArr;
        constructor();
        /**
         * 注册模块
         * @param ServerModule 模块的服务端类型
         * @param ClientModule 模块的客户端类型
         * @param ModuleDataClass 模块的数据类型
         */
        register(ServerModule: Class<IModule>, ClientModule: Class<IModule>, ModuleDataClass: Class<ModuleData<any>>): void;
        private registerServerClient;
        /**
         * 根据类型获取一个模块
         * @param ModuleClass 模块类型
         * @returns 模块
         */
        getModule<T extends IModule>(ModuleClass: Class<T>): T;
        private update;
        /**唤醒所有模块 */
        awakeAllModule(): void;
        /**启动所有模块 */
        startAllModule(): void;
        private startModule;
        /**
         * 所有模块等待资源
         * @param sceneType 场景类型
         */
        waitAssetAllModule(sceneType: number): Promise<void>;
        /**
         * 所有模块模块进入场景
         * @param sceneType 场景类型
         */
        enterSceneAllModule(sceneType: number): void;
        /**销毁所有模块 */
        destroyAllModule(): void;
        /**
         * 遍历所有模块
         * @param executer 每个模块执行的方法
         */
        forEachModule(executer: (moudle: IModule) => void): void;
    }
}

declare module "odin" {
    export class Sound {
        static volumeScale: number;
        onComplete: Action;
        playId: number;
        targetGuid: string;
        private _resId;
        private go;
        private _isDone;
        private _isError;
        private loopNum;
        private _volume;
        constructor(resId: string);
        private init;
        play(loopNum?: number, volume?: number): void;
        playInTarget(target: MWCore.GameObject, loopNum?: number, volume?: number): void;
        playInPos(pos: Type.Vector, loopNum?: number, volume?: number): void;
        private play3D;
        stop(): void;
        private clear;
        set volume(value: number);
        get volume(): number;
        get resId(): string;
        get isDone(): boolean;
        get isError(): boolean;
        clone(): Sound;
    }
}

declare module "odin" {
    export class SoundManager {
        static instance: SoundManager;
        constructor();
        destroy(): void;
        private currentPlayId;
        private preloadSoundDatas;
        private soundMap;
        private pool;
        private playingSound;
        private bgm;
        private init;
        /**
         * 注册预加载声音(框架方法，请勿调用)
         * @param resName 自己定义的资源名称,加载失败的时候报错用
         * @param resId 资源id
         */
        registerPreload(resName: string, resId: string): void;
        /**
         * 预加载所有声音资源(框架方法，请勿调用)
         * @param passFail 有错误是否报出来
         * @returns 是否全部成功
         */
        preloadSound(): Promise<boolean>;
        /**
         * 根据资源id播放声音（可双端调用，不可叠加)
         * @param resId 资源id
         * @param loopNum 循环次数(0无限)
         * @param volume 音量
         * @returns 声音对象
         */
        playSound(resId: string, loopNum?: number, volume?: number): void;
        /**
         * 根据资源id停止声音
         * @param resId 资源id
         */
        stopSound(resId: string): void;
        /**
         * 播放背景音乐（可双端调用)
         * @param resId 资源id
         * @param volume 音量
         */
        playBGM(resId: string, volume?: number): void;
        /**
         * 停止背景音乐（可双端调用)
         */
        stopBGM(): void;
        /**
         * 在目标播放3D音效（可双端调用)
         * @param resId 资源id
         * @param target 播放目标 (GameObject的guid | GameObject | 世界坐标)
         * @param loopNum 循环次数
         * @param volume 音量
         * @returns 播放id，播放声音的唯一标识，可用于停止声音
         */
        play3DSound(resId: string, target: string | MWCore.GameObject | Type.Vector, loopNum?: number, volume?: number): number;
        private net_play3DSoundHandle;
        /**
         * 停止3D声音（可双端调用)
         * @param playId 播放id
         */
        stop3DSound(playId: number): void;
        /**
         * 音量(Client Only)
         */
        set volumeScale(value: number);
        /**
         * 音量(Client Only)
         */
        get volumeScale(): number;
        private update;
        private getSound;
        private getNewPlayId;
        private spawn3DSound;
        private return3DSound;
    }
}

declare module "odin" {
    export class GoNode {
        name: string;
        guid: string;
        children: Array<GoNode>;
        /**
         * 获取一个GameObject的根节点
         * @param go GameObject
         * @returns 根节点
         */
        static get(go: MWCore.GameObject): GoNode;
        /**
         * 根据名字获取节点的一个子节点
         * @param goNode 目标节点
         * @param name 名字
         * @returns 子节点
         */
        static getChildByName(goNode: GoNode, name: string): GoNode;
        /**
         * 根据名字获取节点的所有同名子节点
         * @param goNode 目标节点
         * @param name 名字
         * @returns 子节点序列
         */
        static getChildrenByName(goNode: GoNode, name: string): Array<GoNode>;
        /**
         * 根据guid获取节点的一个子节点
         * @param goNode 目标节点
         * @param guid guid
         * @returns 子节点
         */
        static getChildByGuid(goNode: GoNode, guid: string): GoNode;
        /**
         * 根据路径获取节点的一个子节点
         * @param goNode 目标节点
         * @param path 路径
         * @returns 子节点
         */
        static getChildByPath(goNode: GoNode, path: string): GoNode;
        /**
         * 获取节点某个路径下的所有子节点
         * @param goNode 目标节点
         * @param path 路径
         * @returns 子节点序列
         */
        static getChildrenByPath(goNode: GoNode, path: string): Array<GoNode>;
        /**
         * 生成节点的树形结构字符串
         * @param goNode 目标节点
         * @returns 树形字符串
         */
        static getString(goNode: GoNode): string;
        private static getStringHandle;
    }
}

declare module "odin" {
    export class ResManager {
        static instance: ResManager;
        constructor();
        destroy(): void;
        private _isInit;
        /**
         * 初始化，不要私自调用
         */
        init(): void;
        /**
         * 获取一个GameObject的节点结构(异步，双端调用)
         * @param guid gameObject的guid
         * @returns 节点树结构
         */
        loadGoNode(guid: string): Promise<GoNode>;
        /**
         * 根据路径查找场景中一个GameObject(异步，双端调用)
         * @param path 节点路径
         * @param waitTime 等待时间(单位：毫秒)
         * @returns GameObject
         */
        findGameObjectByPath<T extends MWCore.GameObject>(path: string, waitTime?: number): Promise<T>;
        /**
         * 根据guid查找场景中一个GameObject(异步，双端调用)
         * @param guid guid
         * @param waitTime 等待时间(单位：毫秒)
         * @returns GameObject
         */
        findGameObjectByGuid<T extends MWCore.GameObject>(guid: string, waitTime?: number): Promise<T>;
        /**
         * 根据guid查找场景中一个脚本(异步，双端调用)
         * @param guid guid
         * @param waitTime 等待时间(毫秒)
         * @returns 脚本
         */
        findScriptByGuid<T extends MWCore.MWScript>(guid: string, waitTime?: number): Promise<T>;
        private gameObjectIsOK;
        private netServerGetGameObjectNodeTreeByPath;
        private netServerGetGameObjectNodeTreeByGuid;
        private netServerGetGameObjectGuid;
        private getMWGameObject;
        private getRootMWGameObject;
        /**
         * 从GameObject获取子对象的guid (异步，双端调用)
         * @param targetGo 目标gameObject
         * @param path 节点路径
         * @returns guid
         */
        private getChildGuidFromGo;
        private getScriptGuidFromGo;
        /**
         * 根据路径从GameObject中查找一个子GameObject (异步 双端)
         * @param targetGo 目标GameObject
         * @param path 路径
         * @returns 子GameObject
         */
        findChildFromGo<T extends MWCore.GameObject>(targetGo: string | MWCore.GameObject, path: string): Promise<T>;
        /**
         * 根据路径从GameObject中查找一个脚本 (异步 双端)
         * @param targetGo 目标GameObject
         * @param path 路径
         * @returns 脚本对象
         */
        findScriptFromGo<T extends MWCore.MWScript>(targetGo: string | MWCore.GameObject, path: string): Promise<T>;
        private getGoGuid;
    }
}

declare module "odin" {
    export class InputManager {
        static instance: InputManager;
        constructor();
        destroy(): void;
        private _onTouch;
        private touchInput;
        private beginMulFun;
        private keyDownActionMap;
        private init;
        /**
         * 鼠标点击触发，返回点击的所有结果
         */
        get onTouch(): Action1<Array<GamePlay.HitResult>>;
        /**
         * 按下键盘事件(增加了重复监听的判断，还可以移除监听方法)
         * @param key 按键类型
         * @returns 监听的Action方法
         */
        onKeyDown(key: Type.Keys): Action;
        private initTouch;
        private touchBegin;
        private log;
    }
}

declare module "odin" {
    export class Behaviour {
        private _targetGuid;
        private _gameObject;
        private _script;
        private _endPlayHandle;
        updateEnable: boolean;
        constructor(target: MWCore.GameObject | MWCore.MWScript);
        get targetGuid(): string;
        get gameObject(): MWCore.GameObject;
        get transform(): Type.Transform;
        get script(): MWCore.MWScript;
        protected findChild<T extends MWCore.GameObject>(path: string): Promise<T>;
        protected findScript<T extends MWCore.MWScript>(path: string): Promise<T>;
        private endPlayHandle;
        onAwake(): void;
        onStart(): void;
        onUpdate(dt: number): void;
        onDestroy(): void;
    }
}

declare module "odin" {
    export class BehaviourManager {
        static instance: BehaviourManager;
        constructor();
        destroy(): void;
        private registerList;
        private behaviourMap;
        init(): void;
        addComponent<T extends Behaviour>(target: MWCore.MWBase, BehaviourClass: Class<T>): T;
        getComponent<T extends Behaviour>(target: MWCore.MWBase, BehaviourClass: Class<T>): T;
        deleteComponent(behaviour: Behaviour): void;
        clearComponent(go: MWCore.MWBase): void;
        private update;
    }
}

declare module "odin" {
    export class PreloadRes {
        private static GameObjectPaths;
        /**
         * 注册预等待的gameObejct的路径
         * @param path 路径
         */
        static addWaitGameObject(pathArr: Array<string>): void;
        static addSound(soundDataArr: Array<{
            resName: string;
            resId: string;
        }>): void;
        static addEffect(effectDataArr: Array<{
            resName: string;
            resId: string;
            time: number;
        }>): void;
        static findAllPrewaitGameObject(): Promise<boolean>;
    }
}

declare module "odin" {
    export enum UILayer {
        Bottom = 0,
        Middle = 1,
        Own = 2,
        Top = 3
    }
}

declare module "odin" {
    export interface IPanel {
        /**UI对象*/
        get uiObject(): MWGameUI.MWUIWidget;
        /**画布*/
        get canvas(): MWGameUI.MWUICanvas;
        /**可见性*/
        get visible(): boolean;
        /**可见性*/
        set visible(value: boolean);
        /**
         * Panel放置的UI层
         */
        getLayer(): UILayer;
        /**
         * 显示Panel
         * @param params 参数
         */
        show(...params: any[]): void;
        /**
         * 关闭Panel
         */
        close(): void;
    }
}

declare module "odin" {
    /**
     * 批量Events监听处理
     * 可以将一批注册的事件同时激活或屏蔽
     */
    export class EventListenerBatch {
        private _active;
        private addMap;
        private listenerMap;
        /**
         * 注册监听事件
         * @param eventName 事件名
         * @param callback 监听方法
         */
        add(eventName: string, callback: (...params: unknown[]) => void): void;
        /**
         * 移除监听事件
         * @param eventName 事件名
         */
        remove(eventName: string): void;
        /**
         * 清理所有监听事件
         */
        clear(): void;
        /**是否生效*/
        set active(value: boolean);
        /**是否生效*/
        get active(): boolean;
    }
}

declare module "odin" {
    export class PanelBase extends MWGameUI.MWUIBehaviour implements IPanel {
        private uiPrefab;
        private _visible;
        private _eventListener;
        private isEnabel;
        /**
         * 根据prefab路径，创建一个Panel
         * @param prefabPath ui文件的路径
         * @returns Panel
         */
        static creat<T extends PanelBase>(prefabPath: string): T;
        private OnInitialized;
        private PreConstruct;
        private Construct;
        private OnDestroy;
        /**
         * 根据节点路径查找一个界面元素
         * @param ObjClass 元素类型
         * @param path 节点路径
         * @returns 元素对象
         */
        protected findChildByPath<T extends MWGameUI.MWUIWidget>(ObjClass: {
            new (): T;
            Get(p: MWGameUI.MWUIWidget): T;
        }, path: string): T;
        get canvas(): MWGameUI.MWUICanvas;
        get uiObject(): MWGameUI.MWUIWidget;
        set visible(value: boolean);
        get visible(): boolean;
        show(...params: any[]): void;
        close(): void;
        /**是否处于显示状态*/
        get isShow(): boolean;
        /**名字*/
        get name(): string;
        /**事件批处理*/
        get localEventListener(): EventListenerBatch;
        /**
         * 获取这个Panle应该显示在的UI层，默认在Middle层，如果想换层请复写这个方法
         * @returns UI层
         */
        getLayer(): UILayer;
        /**销毁Panel */
        destroy(): void;
        private enable;
        private disable;
        /**
         * 开始调用
         */
        protected onStart(): void;
        /**
         * 局部完成调用，隐藏的对象不参与UI布局，所以要布局完成后再隐藏，这个方法就是布局完成后调用
         */
        protected onLayout(): void;
        /**
         * 激活调用
         */
        protected onEnable(): void;
        /**
         * 禁用调用
         */
        protected onDisable(): void;
        /**
         * show调用
         * @param params show方法传递的参数
         */
        protected onShow(...params: any[]): void;
        /**
         * close调用
         */
        protected onHide(): void;
        /**
         * 销毁调用
         */
        protected onDestroy(): void;
        /**
         * 刷新调用
         * @param dt 帧间隔时间
         */
        protected onUpdate(dt: number): void;
    }
}

declare module "odin" {
    export class SuperPanelBase implements IPanel {
        private uiPrefab;
        private _visible;
        private _eventListener;
        private defaultPrefabPath;
        /**
         * 不可以直接实例化
         * @param path
         */
        constructor(path: string);
        /**
         * 根据prefab路径，创建一个Panel
         * @param prefabPath ui文件的路径
         * @returns Panel
         */
        static creat<T extends SuperPanelBase>(prefabPath?: string): T;
        /**
         * 根据节点路径查找一个界面元素
         * @param ObjClass 元素类型
         * @param path 节点路径
         * @returns 元素对象
         */
        protected findChildByPath<T extends MWGameUI.MWUIWidget>(ObjClass: {
            new (): T;
            Get(p: MWGameUI.MWUIWidget): T;
        }, path: string): T;
        /**
         * 根据类型路径获取多个子元素，路径是这种形式：`Canvas/Con/Field{0}_txt`
         * @param ObjClass 元素类型
         * @param path 节点路径
         * @returns 元素对象队列
         */
        protected findChildrenByPath<T extends MWGameUI.MWUIWidget>(ObjClass: {
            new (): T;
            Get(p: MWGameUI.MWUIWidget): T;
        }, path: string, startIndex?: number, endIndex?: number): Array<T>;
        get canvas(): MWGameUI.MWUICanvas;
        get uiObject(): MWGameUI.MWUIWidget;
        set visible(value: boolean);
        get visible(): boolean;
        show(...params: any[]): void;
        close(): void;
        /**是否处于显示状态*/
        get isShow(): boolean;
        /**名字*/
        get name(): string;
        /**事件批处理*/
        get localEventListener(): EventListenerBatch;
        /**
         * 获取这个Panle应该显示在的UI层，默认在Middle层，如果想换层请复写这个方法
         * @returns UI层
         */
        getLayer(): UILayer;
        /**销毁Panel */
        destroy(): void;
        /**Panel生成工具自动生成的方法，不要调用 */
        protected buildSelf(): void;
        private enable;
        private disable;
        /**
         * 开始调用
         */
        protected onStart(): void;
        /**
         * 局部完成调用，隐藏的对象不参与UI布局，所以要布局完成后再隐藏，这个方法就是布局完成后调用
         */
        protected onLayout(): void;
        /**
         * 激活调用
         */
        protected onEnable(): void;
        /**
         * 禁用调用
         */
        protected onDisable(): void;
        /**
         * show调用
         * @param params show方法传递的参数
         */
        protected onShow(...params: any[]): void;
        /**
         * close调用
         */
        protected onHide(): void;
        /**
         * 销毁调用
         */
        protected onDestroy(): void;
        /**
         * 刷新调用
         * @param dt 帧间隔时间
         */
        protected onUpdate(dt: number): void;
    }
}

declare module "odin" {
    import * as UE from "ue";
    export abstract class UI extends PanelBase {
        private static _instance;
        static get instance(): UI;
        private readonly LayerMap;
        private creatPanleMap;
        private uniquePanel;
        constructor(obj: UE.Widget);
        /**
         * 显示一个界面
         * @param panel 界面
         * @param layer 图层
         * @returns 显示的界面
         */
        addChild(panel: IPanel, layer?: UILayer): IPanel;
        /**
         * 移除一个显示的界面
         * @param panel 界面
         */
        removeChild(panel: IPanel): void;
        /**
         * 打开一个界面
         * @param PanelClass 界面的类
         * @param prames 显示参数(这个参数可以传递给界面的onShow方法)
         */
        openPanel<T extends SuperPanelBase>(PanelClass: Class<T>, ...prames: any[]): void;
        /**
         * 关闭一个界面
         * @param PanelClass 界面的类
         */
        closePanel<T extends SuperPanelBase>(PanelClass: Class<T>): void;
        /**
         * 判断界面是否处于显示状态
         * @param panel 界面
         * @returns 是否显示
         */
        panelIsShow(panel: IPanel): boolean;
        /**
         * 显示loading
         * @param msg 显示的提示内容
         * @param progress 进度条进度(0-1)
         * @param completeCallBack 完成回调
         */
        protected abstract onShowLoading(msg: string, progress: number, completeCallBack: Function): void;
        /**
         * 隐藏loading
         */
        protected abstract onHideLoading(): void;
        /**
         * 显示loading(字符串调用)
         * @param msg 显示的提示内容
         * @param progress 进度条进度(0-1)
         * @param completeCallBack 完成回调
         */
        private showLoading;
        private getPanel;
        private setAllMiddleAndBottomPanelVisible;
        private getPanelLayer;
        private layoutWidget;
        private static getCanvasSize;
        private static getScreenSize;
        private static getPlayerController;
        private static getCanvasScale;
        /**
         * 获取屏幕尺寸
         * @returns 屏幕尺寸
         */
        static getStageSize(): Type.Vector2;
        /**
         * 将世界坐标转换到屏幕坐标
         * @param worldPos 世界坐标
         * @returns 屏幕坐标
         */
        static getCanvasPointByWorld(worldPos: Type.Vector): Type.Vector2;
    }
}

declare module "odin" {
    export abstract class AnalyticsUtil {
        private static readonly NET_MSG_SEND_MGS;
        private static comData;
        private static msgMap;
        /** 初始化
         * @param comData 公共数据(key-value)
         */
        static init(): void;
        /**
         * 设置公共数据，每个埋点数据都会附加的字段，由key,value的形式组织
         * @param comData 公共数据
         */
        static setCommonData(comData: any): void;
        /** 根据类型生成一个埋点数据对象
         * @param MsgClass 埋点数据类
         * @returns 数据对象
         */
        static get<T extends AnalyticsUtil>(MsgClass: Class<T>): T;
        /**数据说明 */
        abstract desc: string;
        /**数据体 */
        abstract data: any;
        /**
         * 上传埋点数据到潘多拉
         * @param player 在服务端调用时，指定埋点的玩家，如果不写则全房间玩家都上传
         */
        send(player?: GamePlay.Player): void;
    }
}

declare module "odin" {
    export abstract class OdinGame extends MWCore.MWScript {
        private consoleLevel;
        private readonly CONNECT_SERVER;
        protected showLoading: Function;
        protected abstract onRegisterModule(): void;
        protected abstract onPreloadAssets(): void;
        OnStart(): void;
        OnUpdate(dt: number): void;
        OnDestroy(): void;
        private enterGame;
        private exitGame;
        private initServer;
        protected initClient(): Promise<void>;
        protected onInitClientComplete(): void;
    }
}

declare module "odin" {
    /**
     * 战斗对象抽象接口
     */
    export interface IFightRole {
        /**
        * 是否死亡
        */
        isDead: boolean;
        /**
         * 死亡动画播放完成，死透了
         */
        onDeadComplete(): void;
        /**
         * 当前位置
         */
        location: Type.Vector;
        /**
         * 角色对象
         */
        character: GamePlay.Character | GamePlay.AICharacter;
        /**
         * 被伤害
         * @param Attacker 攻击者
         * @param val 伤害值
         */
        onHurt(Attacker: IFightRole, val: number): void;
        /**
         * 移动到目的地
         * @param pos 目的地
         * @param radius 半径
         * @param callBack 移动完成回调
         */
        moveTo(pos: Type.Vector, radius: number, callBack: Function): void;
        /**
         * 停止移动
         */
        stopMove(): void;
        /**
         * 看向某个方向
         * @param pos 目标点
         */
        lookAt(pos: Type.Vector): any;
        /**
        * 是否在移动
        */
        isMoving(): boolean;
        /**
         * 获取一个可释放的技能
         */
        getSkill(): number;
        /**
         * 释放技能
         * @param target 目标
         * @param skill 技能id
         */
        releaseSkill(target: IFightRole, skill: number): void;
        /**
         * 最大可释放技能距离，寻路时候用
         */
        getMaxAttackDis(): number;
        /**
         * 最大追踪距离，超过了应该返回出生点
         */
        getMaxTrackDis(): number;
        /**
         * 检测当前对象是否合法可攻击
         */
        checkTargetValid(target: IFightRole): boolean;
        /**
         * 清除当前对象
         * @param target 和当前对象对比，一样的才清除
         */
        clearCurTarget(target: IFightRole): void;
        /**
         * 找一个对象
         */
        findATarget(): IFightRole;
        /**
         * 设置当前对象
         * @param target 目标对象
         */
        setCurTarget(target: IFightRole): void;
        /**
         * 当前锁定的对象
         */
        getCurTarget(): IFightRole;
        /**
         * 返回出生点的位置
         */
        getBack2Pos(): Type.Vector;
        /**
         * 找目标的视野
         */
        getEyeDis(): number;
        /**
         * 战斗实体类型，用来区分玩家，怪物等
         */
        getType(): number;
        /**
         * 更新
         */
        update(): void;
        /**
         * 遍历所有战斗对象
         * @param call 回调函数
         */
        forEachFightRole(call: (role: IFightRole) => void): void;
        /**
         * 播放动画
         * @param guid 动画guid
         * @param pos 目标位置
         */
        playAnimation(guid: string, pos: Type.Vector): any;
    }
}

declare module "odin" {
    export interface IAIState {
        /**
        * 状态进入，外部调用
        * @param context 战斗实体
        */
        enter(context: IFightRole): any;
        /**
         * 更新，外部驱动
         */
        onUpdate(): any;
        /**
         * 退出状态外部调用
         */
        exit(): any;
        /**
         * 销毁
         */
        onDestory(): any;
        /**
         * 切换状态
         * @param type 状态类型
         */
        change2State(type: number): void;
    }
}

declare module "odin" {
    export class AIMachine {
        private currentState;
        private stateMap;
        private owner;
        constructor(owner: IFightRole);
        /**
         * 注册状态
         * @param type 状态机类型
         * @param newstate 状态对象
         */
        register(type: number, newstate: IAIState): void;
        /**
        * 状态轮询：调用子状态
        */
        update(): void;
        /**
        * 切换状态：立即转换到新的状态（参数自己注册时填写）
        * @param type 新的状态
        */
        changeState(type: number): void;
        destory(): void;
    }
}

declare module "odin" {
    export abstract class AIState implements IAIState {
        protected context: IFightRole;
        protected owner: AIMachine;
        constructor(owner: AIMachine);
        /**
         * 切换状态
         * @param type 状态类型
         */
        change2State(type: number): void;
        /**
         * 状态进入，外部调用
         * @param context 战斗实体
         */
        enter(context: IFightRole): void;
        /**
         * 退出状态外部调用
         */
        exit(): void;
        /**
         * 销毁
         */
        onDestory(): void;
        /**
         * 子状态重写，enter之后触发
         */
        protected abstract onEnter(): any;
        /**
        * 子状态重写，exit之后触发
        */
        protected abstract onExit(): any;
        /**
         * 更新，外部驱动
         */
        abstract onUpdate(): any;
    }
}

declare module "odin" {
    export class NetBehaviour extends Behaviour {
        registerToNet(): void;
        protected callServerFun(funName: string, ...prames: any[]): Promise<any>;
        protected callClientFun(player: GamePlay.Player, funName: string, ...params: any[]): void;
        protected callAroundClientFun(player: GamePlay.Player, funName: string, ...params: any[]): void;
        protected callWorldClientFun(funName: string, ...params: any[]): void;
    }
}

declare module "odin" {
    export class NetBehaviourCreator extends MWCore.MWScript {
        private _behaviour;
        protected creatBehaviour(ServerClass: Class<NetBehaviour>, ClientClass: Class<NetBehaviour>): void;
        behaviour(): NetBehaviour;
        protected OnDestroy(): void;
    }
}

declare module "odin" {
    export class NetObjectS<T> extends NetObject {
        private _client;
        private netFunNameMap;
        private callClientObj;
        /**
         * 构造
         * @param netGuid 通信id
         * @param ClientClass 客户端类
         * @param autoRegister 是否自动注册
         */
        constructor(netGuid: string, ClientClass: Class<T>, autoRegister?: boolean);
        private clientClassToCallHandler;
        private replaceNetFun;
        private getCallClientFun;
        /**
         * 和自己绑定的客户端对象，可通过此对象直接调用net_开头的客户端方法
         */
        protected get client(): T;
        /**
         * 当前调用服务器方法的玩家
         */
        protected get currentPlayer(): GamePlay.Player;
        /**
         * 调用目标客户端的方法
         * @param player 目标客户端
         * @param fun 方法名|方法对象|方法调用结果
         * @param params 参数
         */
        protected callClientFun(player: GamePlay.Player, fun: string | Function | void, ...params: any[]): void;
        /**
         * 调用目标周围客户端的方法
         * @param player 目标客户端
         * @param fun 方法名|方法对象|方法调用结果
         * @param params 参数
         */
        protected callAroundClientFun(player: GamePlay.Player, fun: string | Function | void, ...params: any[]): void;
        /**
         * 调用所有客户端的方法
         * @param fun 方法名|方法对象|方法调用结果
         * @param params 参数
         */
        protected callWorldClientFun(fun: string | Function | void, ...params: any[]): void;
        private setCallClientObj;
    }
}

declare module "odin" {
    export abstract class ModuleS<T, S extends ModuleData<any>> extends NetObjectS<T> implements IModule {
        private ModuleDataClass;
        /**
         * 构造(不要手动构造模块，请在GameStart中注册)
         * @param ClientModuleClass 模块客户端类
         * @param ModuleDataClass 模块数据类
         * @param netGuid 通信id
         */
        constructor(ClientModuleClass: Class<T>, ModuleDataClass: Class<S>, netGuid: string);
        /** 获取当前请求玩家的本模块数据控制*/
        protected get currentData(): S;
        /**
         * 获取玩家的本模块数据
         * @param player 目标玩家
         * @returns 数据
         */
        protected getPlayerData(player: GamePlay.Player): S;
        /**创建调用*/
        onAwake(): void;
        /**开始调用*/
        onStart(): void;
        /**刷新调用*/
        onUpdate(dt: number): void;
        /**销毁调用*/
        onDestroy(): void;
        /**执行操作*/
        execute(param?: number, data?: any): void;
    }
}

declare module "odin" {
    export class ViewBase {
        private uiPrefab;
        constructor(prefabPath: string);
        protected findChildByPath<T extends MWGameUI.MWUIWidget>(ObjClass: {
            new (): T;
            Get(p: MWGameUI.MWUIWidget): T;
        }, path: string): T;
    }
}

declare module "odin" {
    /**
     * 摄像机工具类，用于实现震屏、摄像机跟随等效果
     */
    export class CameraUtil {
        private static _character;
        private static forward;
        private static speed;
        private static maxRange;
        private static lastOffSize;
        private static decay;
        private static get character();
        /**
         * 震屏
         * @param maxRange 最大幅度
         * @param decay 每个周期的衰减
         * @param speed 速度
         */
        static screenShock(maxRange?: number, decay?: number, speed?: number): void;
        private static screenShockFinish;
        private static screenShockUpdate;
        /**
         * 跟随目标
         * @param target 目标
         */
        static setFollowTarget(target: MWCore.GameObject): void;
    }
}

declare module "odin" {
    /**
     * 数学工具
     */
    export class MathUtil {
        /**
         * 获取两个向量之间的距离
         * @param v1 第一个向量
         * @param v2 第二个向量
         * @returns 距离
         */
        static distance(v1: Type.Vector, v2: Type.Vector): number;
        /**
         * 获取两个向量之间的距离的平方
         * @param v1 第一个向量
         * @param v2 第二个向量
         * @returns 距离
         */
        static distanceSquare(v1: Type.Vector, v2: Type.Vector): number;
        /**
         * 一个点往目标点移动一个距离
         * @param currentPos 当前点
         * @param targetPos 目标点
         * @param moveDis 移动的距离
         * @param resPos 移动后得到的结果的点
         * @returns 是否移动到了目标点
         */
        static posMove(currentPos: Type.Vector, targetPos: Type.Vector, moveDis: number, resPos: Type.Vector): boolean;
        /**
         * 向量的线性插值
         * @param from 起始向量
         * @param to 目标向量
         * @param alpha alpha
         * @returns 新向量
         */
        static vectorLerp(from: Type.Vector, to: Type.Vector, alpha: number): Type.Vector;
        /**
         * 获取一个区间的整随机数
         * @param min 最小值
         * @param max 最大值(不包含)
         * @returns 随机数
         */
        static getRandom(min: number, max: number): number;
        /**
         * 获取两个旋转之间的欧拉角
         * @param from 起始旋转
         * @param to 目标旋转
         * @returns 欧拉角
         */
        static getEulerAngles(from: Type.Rotation, to: Type.Rotation): Type.Vector;
        /**
         * Rotation转欧拉角
         * @param rotation Rotation
         * @returns 欧拉角
         */
        static rotationToAngles(rotation: Type.Rotation): Type.Vector;
        /**
         * 获取局部欧拉角
         * @param go GameObject
         * @returns 欧拉角
         */
        static getLocalEulerAngles(go: MWCore.GameObject): Type.Vector;
        /**
         * 向量点积
         * @param a 第一个向量
         * @param b 第二个向量
         * @returns 点积结果
         */
        static dot(a: Type.Vector, b: Type.Vector): number;
        /**
         * 向量叉积
         * @param a 第一个向量
         * @param b 第二个向量
         * @returns 叉积结果
         */
        static cross(a: Type.Vector, b: Type.Vector): Type.Vector;
        /**
         * 获取两个向量的旋转角
         * @param from 起始向量
         * @param to 目标向量
         * @param up 旋转轴
         * @returns 旋转的角度
         */
        static getSignedAngle(from: Type.Vector, to: Type.Vector, up: Type.Vector): number;
    }
}

declare module "odin" {
    export class GoPool {
        static instance: GoPool;
        constructor();
        destroy(): void;
        private readonly POOL_RES_GUID;
        private sceneSource;
        private subPoolMap;
        /**
         * 生成一个对象
         * @param guid 场景中对象的guid或资源的guid
         * @returns 对象
         */
        spawn<T extends MWCore.GameObject>(guid: string): T;
        /**
         * 归还一个对象
         * @param obj 对象
         */
        unSpawn(obj: MWCore.GameObject): void;
        /**
         * 清除对象池中所以guid对应的对象
         * @param guid 清除对象的guid
         */
        clear(guid: string): void;
    }
    export class ObjPool<T> {
        private creatFunction;
        private resetFunction;
        private destroyFunction;
        private freeObjs;
        /**
         * 构造一个对象池
         * @param creatObj 创建新对象的回调
         * @param onReset 重置对象的回调
         * @param onDestroy 销毁对象的回调
         * @param initNum 默认缓存对象数量
         */
        constructor(creatObj: () => T, onReset: (obj: T) => void, onDestroy: (obj: T) => void, initNum?: number);
        /**
         * 生成一个对象
         * @returns 对象
         */
        spawn(): T;
        /**
         * 归还一个对象
         * @param obj 对象
         */
        unSpawn(obj: T): void;
        /**
         * 获取对象池中空闲对象的数量
         */
        get size(): number;
        /**
         * 清除
         */
        clear(): void;
        getFreeObjs(): Array<T>;
    }
}

declare module "odin" {
    /**
     * Tween.js - Licensed under the MIT license
     * https://github.com/tweenjs/tween.js
     * ----------------------------------------------
     *
     * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
     * Thank you all, you're awesome!
     */
    export class Sequence {
        private static _nextId;
        static nextId(): number;
    }
    export let now: () => number;
    export type InterpolationFunction = (v: number[], k: number) => number;
    /**
     *
     */
    export const Interpolation: {
        Linear: (v: number[], k: number) => number;
        Bezier: (v: number[], k: number) => number;
        CatmullRom: (v: number[], k: number) => number;
        Utils: {
            Linear: (p0: number, p1: number, t: number) => number;
            Bernstein: (n: number, i: number) => number;
            Factorial: (n: number) => number;
            CatmullRom: (p0: number, p1: number, p2: number, p3: number, t: number) => number;
        };
    };
    export class Group {
        private _tweens;
        private _tweensAddedDuringUpdate;
        getAll(): Array<Tween<UnknownProps>>;
        removeAll(): void;
        add(tween: Tween<UnknownProps>): void;
        remove(tween: Tween<UnknownProps>): void;
        update(time?: number, preserve?: boolean): boolean;
    }
    export const mainGroup: Group;
    export type EasingFunction = (amount: number) => number;
    /**
     * The Ease class provides a collection of easing functions for use with tween.js.
     */
    export const Easing: {
        Linear: {
            None: (amount: number) => number;
        };
        Quadratic: {
            In: (amount: number) => number;
            Out: (amount: number) => number;
            InOut: (amount: number) => number;
        };
        Cubic: {
            In: (amount: number) => number;
            Out: (amount: number) => number;
            InOut: (amount: number) => number;
        };
        Quartic: {
            In: (amount: number) => number;
            Out: (amount: number) => number;
            InOut: (amount: number) => number;
        };
        Quintic: {
            In: (amount: number) => number;
            Out: (amount: number) => number;
            InOut: (amount: number) => number;
        };
        Sinusoidal: {
            In: (amount: number) => number;
            Out: (amount: number) => number;
            InOut: (amount: number) => number;
        };
        Exponential: {
            In: (amount: number) => number;
            Out: (amount: number) => number;
            InOut: (amount: number) => number;
        };
        Circular: {
            In: (amount: number) => number;
            Out: (amount: number) => number;
            InOut: (amount: number) => number;
        };
        Elastic: {
            In: (amount: number) => number;
            Out: (amount: number) => number;
            InOut: (amount: number) => number;
        };
        Back: {
            In: (amount: number) => number;
            Out: (amount: number) => number;
            InOut: (amount: number) => number;
        };
        Bounce: {
            In: (amount: number) => number;
            Out: (amount: number) => number;
            InOut: (amount: number) => number;
        };
        generatePow: (power?: number) => {
            In(amount: number): number;
            Out(amount: number): number;
            InOut(amount: number): number;
        };
    };
    export class Tween<T extends UnknownProps> {
        private _object;
        private _group;
        private _isPaused;
        private _pauseStart;
        private _valuesStart;
        private _valuesEnd;
        private _valuesStartRepeat;
        private _duration;
        private _initialRepeat;
        private _repeat;
        private _repeatDelayTime?;
        private _yoyo;
        private _isPlaying;
        private _reversed;
        private _delayTime;
        private _startTime;
        private _easingFunction;
        private _interpolationFunction;
        private _chainedTweens;
        private _onStartCallback?;
        private _onStartCallbackFired;
        private _onUpdateCallback?;
        private _onRepeatCallback?;
        private _onCompleteCallback?;
        private _onStopCallback?;
        private _id;
        private _isChainStopped;
        constructor(_object: T, _group?: Group | false);
        getId(): number;
        isPlaying(): boolean;
        isPaused(): boolean;
        to(properties: UnknownProps, duration?: number): this;
        duration(d?: number): this;
        start(time?: number): this;
        private _setupProperties;
        stop(): this;
        end(): this;
        pause(time?: number): this;
        resume(time?: number): this;
        stopChainedTweens(): this;
        group(group?: Group): this;
        delay(amount?: number): this;
        repeat(times?: number): this;
        repeatDelay(amount?: number): this;
        yoyo(yoyo?: boolean): this;
        easing(easingFunction?: EasingFunction): this;
        interpolation(interpolationFunction?: InterpolationFunction): this;
        chain(...tweens: Array<Tween<any>>): this;
        onStart(callback?: (object: T) => void): this;
        onUpdate(callback?: (object: T, elapsed: number) => void): this;
        onRepeat(callback?: (object: T) => void): this;
        onComplete(callback?: (object: T) => void): this;
        onStop(callback?: (object: T) => void): this;
        private _goToEnd;
        /**
         * @returns true if the tween is still playing after the update, false
         * otherwise (calling update on a paused tween still returns true because
         * it is still playing, just paused).
         */
        update(time?: number, autoStart?: boolean): boolean;
        private _updateProperties;
        private _handleRelativeValue;
        private _swapEndStartRepeatValues;
    }
    export type UnknownProps = Record<string, any>;
    export default Tween;
    const VERSION = "18.6.4";
    const nextId: typeof Sequence.nextId;
    const getAll: any;
    const removeAll: any;
    const add: any;
    const remove: any;
    const update: any;
    export { nextId, VERSION, getAll, removeAll, add, remove, update };
}
